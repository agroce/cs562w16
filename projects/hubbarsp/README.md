## Project Proposal

My project proposal is to use the Template Scripting Testing Language
([TSTL][tstl]) to define a test harness for the `sqlparse` Python module. The
module provides a parser for SQL statements. The parser takes a string for a SQL
statement and returns an object for the parse tree of the SQL statement. The
module also provides classes and methods for analyzing parse trees of SQL
statements.

### Test Goal

The parser provided by the `sqlparse` module will be tested for correctness on
the simplified version of SQL, which I will call the "object language". Note
that the object language is defined by the grammars below. The parser is
considered "correct" if the returned object represents the parse tree of the
input statement, for any statement in the object language. The XML example from
[TSTL][tstl] will be used to guide the initial design.

### Install Module

The `sqlparse` module is compatible with both Python 2.7 and Python 3. The
project page and repository for the module is located [here][sqlparse]. There
are several ways to install the module.

One way to install the module is by cloning the [repository][sqlparse] and then
running the setup script:

```bash
$ python setup.py install
```

Another way to install the module is by using pip:

```bash
$ pip install sqlparse
```

Note that the version of the module installed using pip might be older and
incompatible with the version targeted by the test harness.

### Test Module

A simple test harness for the `sqlparse` module is defined by `mysqlparse.tstl`.
The test harness is generated using TSTL:

```bash
$ rm sut.*
$ tstl --nocover mysqlparse.tstl
```

These commands will generate the test harness (without coverage) named `sut.py`
and `sut.pyc`.

For the next two commands, the path to the random tester and model checker
should be replaced. An example run of the random tester:

```bash
$ python ../../../tstl/generators/randomtester.py --nocover --maxtest=100 --depth=50
```

An example run of the breadth first search (BFS) model checker:

```bash
$ python ../../../tstl/generators/bfsmodelchecker.py --nocover --forget=0.5 --depth=50
```

Note that model checker has not actually run on the test harness.

## Bug Report

No bugs have been found in the parser. Several failing tests have been generated
by the random tester. However, these failing tests were related to incorrect
actions in the test harness and not bugs in the parser. For example, an action
that allowed a string derivable from `<sel>` to be terminated by a semicolon and
used in used in a `<tab>` production would lead to a failing test but would not
lead to a legal statement, see grammars below.

The fact that no bugs have been found indicates that the quality of the parser
is high with respect to the simplified version of standard SQL that is tested,
i.e., the object language. It is likely that the parser was designed for a
variant of SQL similar to the object language being tested. The quality of the
parser for other variants of SQL is unknown. 

Originally, the testing harness was designed for testing `SELECT` statements.
The testing harness has been redesigned for testing both `SELECT` and
`CREATE TABLE` statements. To accommodate testing both `SELECT` and
`CREATE TABLE` statements with the same test harness, the grammar defining
`SELECT` statements has been simplified further and the grammar defining
`CREATE TABLE` statements has been added, see grammars below. This means both
pools and actions had to be changed in the test harness. However, the main
assertion used for detecting bugs was not changed because it is both simple and
accurate.

In the future, the testing harness will be redesigned for testing smaller
syntactic categories in SQL---in contrast with complete SQL statements. In
principle, TSTL should be suitable for defining a test harness designed for
building and testing for SQL statements. However, it can be difficult to define
the pools and actions necessary for efficient test generation.

Complete SQL statements are syntactically complicated. This means a test harness
that is designed for building and testing SQL statements must have many
different actions that correspond to production rules in the grammar, which
means any test generated by the test harness must consist of a correctly ordered
sequence of these actions. If the tests are being generated randomly, then the
probability of generating such a sequence could be low.

I used two approaches to ensure efficient test generation:

1. **Changes to the test harness definition.** For example, sometimes it is
   useful to specify that an action does not count as a pool "use". As another
   example, sometimes the total number of pools can be reduced by increasing
   redundancy in some parts of some actions.
2. **Changes to the object language definition.** For example, removing optional
   syntax from a statement can lead to fewer actions and pools.

A drawback of the first approach is that it can be difficult to know if a change
to the test harness definition will effect the possible statements that can be
generated. Another drawback of the first approach is that it can lead to code
duplication in the actions. A drawback of the second approach is that it can
lead to a "worse" test harness.

### Grammar

The structured query language (SQL) consists of two sublanguages: the data
definition language (DDL) and the data manipulation language (DML). The object
language will consist of simplified DDL and DML statements. Concrete syntax
common to both DDL and DML statements is given by the following grammar:

```
<name>       ::= (any name not a keyword)
<qual-name>  ::= <name> | <name> . <name>
<qual-names> ::= <qual-name> [, <qual-name>]
```

DDL statements in the object language are simplified `CREATE` statements.
Concrete syntax specific to DDL statements is given by the following grammar:

```
<type>  ::= INT | FLOAT | VARCHAR ( <len> )
<len>   ::= (any non-negative integer)

<const> ::= NOT NULL | UNIQUE | PRIMARY KEY

<cols>  ::= <name> [<type>] [<const>] [, <cols>]

<ddl>   ::= CREATE TABLE <qual-name> ( <cols> ) ;
```

DML statements in the object language are simplified `SELECT` statements.
Concrete syntax specific to DML statements is given by the following grammar:

```
<num>     ::= (any number)
<str>     ::= (any quoted string)
<bool>    ::= TRUE | FALSE | UNKNOWN

<row-op>  ::= < | <= | > | >= | = | <>
<pred-op> ::= AND | OR

<row>     ::= <num> | <str> | <qual-name>

<pred>    ::= <row> [IS [NOT] NULL]
            | <row> <row-op> <row>
            | [NOT] <pred> [IS [NOT] <bool>]
            | <pred> <pred-op> <pred>
            | ( <pred> )

<cols>    ::= * | <qual-names>

<tab>     ::= <qual-names> | ( <sel> )

<sel>     ::= SELECT <cols> FROM <tab> [WHERE <pred>]

<dml>     ::= <sel> ;
```

[tstl]: https://github.com/agroce/tstl
[sqlparse]: https://github.com/andialbrecht/sqlparse
