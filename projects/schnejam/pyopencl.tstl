#Instructions: SEE README ON HOW TO INSTALL pyopencl (into a virtualenv if you wish) using pip

@import reductions as red
@import math
@import numpy as np

<@
def compare_fold(arr, func):
    gpu_result = red.pyopencl_fold_with(arr, func)
    cpu_result = red.python_fold_with(arr, func)
    success = gpu_result == cpu_result
    if not success: print(arr)
    assert success
    return np.arange(cpu_result, dtype=np.int32)

def compare_zip(arr, func):
    gpu_result = red.pyopencl_zip_with(arr, func)
    cpu_result = red.python_zip_with(arr, func)
    success = (gpu_result == cpu_result).all()
    if not success: print(arr)
    assert success
    return cpu_result

def compare_predicates(arr, func):
    assert red.pyopencl_filter(arr, func)

def compare_unique(arr):
    assert red.pyopencl_unique(arr)
@>

pool: <seed> 3
<seed> := <[1..20]>

pool: <length> 3
<length> := int(red.array_len(<[1..13]>))

pool: <array> 3
<array> := red.get_cpu_data(seed=<seed>, min_endpoint=-10, max_endpoint=10, length=<length>)

#valid GPU operations for folding must be associative
pool: <afunc> 3
<afunc> := "a+b"  # "a*b" results in overflow for even small values

#valid GPU comparison operations
pool: <ufunc> 3
<ufunc> := <["ary[i] > val", "ary[i] < val", "ary[i] >= val", "ary[i] <= val", "ary[i] == val"]>


<array,1> = compare_fold(<array>, <afunc>)
<array,1> = compare_zip(<array>, <afunc>)
compare_predicates(<array>, <ufunc>)
compare_unique(<array>)
